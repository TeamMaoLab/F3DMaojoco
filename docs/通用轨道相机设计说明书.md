# MuJoCo é€šç”¨è½¨é“ç›¸æœºè®¾è®¡è¯´æ˜ä¹¦

## å‰è¨€

æœ¬æ–‡æ¡£æ˜¯åŸºäºé¡¹ç›®å®è·µç»éªŒçš„ç»¼åˆæ€§ç›¸æœºè®¾è®¡æŒ‡å—ï¼Œæ•´åˆäº†è®¾è®¡å†³ç­–ã€å®ç°å‚è€ƒå’Œå…·ä½“å®æ–½æ–¹æ¡ˆã€‚æ—¨åœ¨ä¸ºä»»ä½•éœ€è¦ 3D ç›¸æœºæ§åˆ¶çš„åº”ç”¨æä¾›å®Œæ•´ã€å¯å¤ç”¨çš„è§£å†³æ–¹æ¡ˆã€‚

---

## 1. è®¾è®¡æ¦‚è¿°

### 1.1 è®¾è®¡ç›®æ ‡
æœ¬ç›¸æœºç³»ç»Ÿè®¾è®¡æ—¨åœ¨ä¸º MuJoCo 3D ä»¿çœŸç¯å¢ƒæä¾›ä¸€ä¸ªåŠŸèƒ½å®Œæ•´ã€æ˜“äºé›†æˆçš„é€šç”¨è½¨é“ç›¸æœºæ§åˆ¶å™¨ã€‚è¯¥è®¾è®¡å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **é€šç”¨æ€§**ï¼šé€‚ç”¨äºä»»ä½• MuJoCo æ¨¡å‹
- **ç›´è§‚äº¤äº’**ï¼šæ”¯æŒé¼ æ ‡å’Œé”®ç›˜çš„ç›´è§‚æ“ä½œ
- **å¯æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ï¼Œæ˜“äºé›†æˆåˆ°å„ç§åº”ç”¨ä¸­
- **é«˜æ€§èƒ½**ï¼šä¼˜åŒ–çš„æ¸²æŸ“å’Œäº¤äº’é€»è¾‘

### 1.2 æ ¸å¿ƒåŠŸèƒ½
- 360Â° è½¨é“æ—‹è½¬è§‚å¯Ÿ
- å¹³ç§»å’Œç¼©æ”¾æ§åˆ¶
- è‡ªé€‚åº”è§†è·å’Œè£å‰ªå¹³é¢
- é”®ç›˜å¿«æ·é”®æ”¯æŒ
- å®æ—¶å‚æ•°ç›‘æ§

### 1.3 è®¾è®¡åŸåˆ™
1. **æ­£ç¡®æ€§ > æ€§èƒ½ > åŠŸèƒ½**
2. **ç”¨æˆ·ä½“éªŒ > åŠŸèƒ½æ•°é‡**
3. **å¯ç»´æŠ¤æ€§ > ä»£ç ç®€æ´æ€§**
4. **æ‰©å±•æ€§ > å½“å‰éœ€æ±‚**

---

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 è®¾è®¡å†³ç­–çŸ©é˜µ

#### 2.1.1 ç›¸æœºè¡¨ç¤ºæ–¹æ¡ˆ

| æ–¹æ¡ˆ | ä¼˜ç‚¹ | ç¼ºç‚¹ | é€‚ç”¨åœºæ™¯ |
|------|------|------|----------|
| **æ¬§æ‹‰è§’** âœ“ | ç›´è§‚æ˜“ç†è§£ã€å­˜å‚¨ç®€å• | ä¸‡å‘èŠ‚é”ã€æ’å€¼å¤æ‚ | è½¨é“æŸ¥çœ‹å™¨ |
| å››å…ƒæ•° | æ— ä¸‡å‘èŠ‚é”ã€æ’å€¼å¹³æ»‘ | ä¸ç›´è§‚ã€è°ƒè¯•å›°éš¾ | åŠ¨ç”»ã€ç›¸æœºè¿åŠ¨ |
| å˜æ¢çŸ©é˜µ | ç»Ÿä¸€æ•°å­¦æ¡†æ¶ | å†—ä½™ã€éš¾è°ƒè¯• | å¤æ‚å˜æ¢ |
| LookAtå‚æ•° | ç¬¦åˆç›´è§‰ã€APIå‹å¥½ | è®¡ç®—å¼€é”€ | ç®€å•æŸ¥çœ‹å™¨ |

**é€‰æ‹©ç†ç”±**ï¼šè½¨é“æŸ¥çœ‹å™¨ä¸­ï¼Œç”¨æˆ·äº¤äº’ä¸»è¦æ˜¯æ°´å¹³+å‚ç›´æ—‹è½¬ï¼Œæ¬§æ‹‰è§’(azimuth/elevation)æœ€ç¬¦åˆç”¨æˆ·ç›´è§‰ã€‚

#### 2.1.2 åæ ‡ç³»ç»Ÿé€‰æ‹©

| æ–¹æ¡ˆ | å®šä¹‰ | ä¼˜ç‚¹ | ç¼ºç‚¹ |
|------|------|------|------|
| Y-Up | Blender/Unityé£æ ¼ | è¡Œä¸šæ ‡å‡† | æ•°å­¦è®¡ç®—ç¨å¤æ‚ |
| **Z-Up** âœ“ | MuJoCo/ç§‘å­¦è®¡ç®— | ç®€åŒ–çƒé¢è®¡ç®— | ä¸æ¸¸æˆå¼•æ“ä¸ä¸€è‡´ |
| ç›¸æœºç©ºé—´ | ä»¥ç›¸æœºä¸ºåŸç‚¹ | ç®€åŒ–æŠ•å½±è®¡ç®— | ä¸–ç•Œåæ ‡è½¬æ¢å¤æ‚ |

**é€‰æ‹©ç†ç”±**ï¼šMuJoCoä½¿ç”¨Z-Upï¼Œæˆ‘ä»¬éµå¾ªå¼•æ“çº¦å®šï¼Œç®€åŒ–åæ ‡è½¬æ¢ã€‚

#### 2.1.3 ç¼©æ”¾å®ç°æ–¹æ¡ˆ

| æ–¹æ¡ˆ | æ•°å­¦å®ç° | ç”¨æˆ·ä½“éªŒ | æ€§èƒ½ |
|------|----------|----------|------|
| çº¿æ€§ç¼©æ”¾ | `d += step * speed` | ç®€å•ç›´æ¥ | è·ç¦»è¶Šè¿‘è¶Šå¿« |
| **æŒ‡æ•°ç¼©æ”¾** âœ“ | `d *= exp(step * speed)` | é€Ÿåº¦æ’å®š | ç¨æœ‰è®¡ç®—å¼€é”€ |
| å¯¹æ•°ç¼©æ”¾ | `d += log(step) * speed` | ç²¾ç»†æ§åˆ¶ | åç›´è§‰ |
| è‡ªé€‚åº”ç¼©æ”¾ | æ ¹æ®è·ç¦»è°ƒæ•´speed | æœ€çµæ´» | å‚æ•°è°ƒä¼˜å¤æ‚ |

**é€‰æ‹©ç†ç”±**ï¼šæŒ‡æ•°ç¼©æ”¾æä¾›äº†æœ€ä¸€è‡´çš„ç”¨æˆ·ä½“éªŒï¼Œè·ç¦»å˜åŒ–é€Ÿåº¦ä¸ç”¨æˆ·æ„ŸçŸ¥ä¸€è‡´ã€‚

### 2.3 é‡è¦æ¦‚å¿µè§£é‡Š

#### 2.3.1 ä¸‡å‘èŠ‚é”ï¼ˆGimbal Lockï¼‰

**ä»€ä¹ˆæ˜¯ä¸‡å‘èŠ‚é”ï¼Ÿ**

ä¸‡å‘èŠ‚é”æ˜¯æ¬§æ‹‰è§’æ—‹è½¬ç³»ç»Ÿä¸­çš„ä¸€ä¸ªç»å…¸é—®é¢˜ã€‚å½“å…¶ä¸­ä¸€ä¸ªæ—‹è½¬è½´ï¼ˆé€šå¸¸æ˜¯ç¬¬äºŒä¸ªæ—‹è½¬è½´ï¼‰æ—‹è½¬åˆ°Â±90Â°æ—¶ï¼Œä¼šå¯¼è‡´å¦å¤–ä¸¤ä¸ªæ—‹è½¬è½´é‡åˆï¼Œä»è€Œå¤±å»ä¸€ä¸ªæ—‹è½¬è‡ªç”±åº¦ã€‚

**ç›´è§‚ç†è§£ï¼š**

æƒ³è±¡ä¸€ä¸ªçœŸå®çš„ä¸‡å‘èŠ‚è£…ç½®ï¼š
1. æœ€å¤–å±‚ç¯ï¼šæ°´å¹³æ—‹è½¬ï¼ˆazimuthï¼Œæ–¹ä½è§’ï¼‰
2. ä¸­é—´å±‚ç¯ï¼šå‚ç›´æ—‹è½¬ï¼ˆelevationï¼Œä»°è§’ï¼‰  
3. æœ€å†…å±‚ç¯ï¼šæ»šè½¬æ—‹è½¬ï¼ˆrollï¼Œæ»šè½¬è§’ï¼‰

å½“ä¸­é—´å±‚ç¯æ—‹è½¬åˆ°å‚ç›´ä½ç½®ï¼ˆ90Â°æˆ–-90Â°ï¼‰æ—¶ï¼Œæœ€å¤–å±‚å’Œæœ€å†…å±‚çš„æ—‹è½¬è½´ä¼šé‡åˆåœ¨ä¸€æ¡ç›´çº¿ä¸Šï¼Œæ­¤æ—¶æ— è®ºæ€ä¹ˆè½¬åŠ¨æœ€å¤–å±‚æˆ–æœ€å†…å±‚ï¼Œæ•ˆæœéƒ½æ˜¯ä¸€æ ·çš„â€”â€”è¿™å°±ä¸¢å¤±äº†ä¸€ä¸ªæ—‹è½¬ç»´åº¦ã€‚

**æ•°å­¦åŸç†ï¼š**

åœ¨æˆ‘ä»¬çš„è½¨é“ç›¸æœºä¸­ï¼Œä½¿ç”¨çƒåæ ‡ç³»(azimuth, elevation, distance)ï¼š
- azimuthï¼šæ°´å¹³æ–¹ä½è§’ï¼ˆ0-360Â°ï¼‰
- elevationï¼šå‚ç›´ä»°è§’ï¼ˆæˆ‘ä»¬é™åˆ¶åœ¨-89.9Â°åˆ°89.9Â°ï¼‰
- distanceï¼šè§‚å¯Ÿè·ç¦»

å½“elevationæ¥è¿‘Â±90Â°æ—¶ï¼Œazimuthçš„æ—‹è½¬æ•ˆæœä¼šé€æ¸å‡å¼±ï¼Œæœ€ç»ˆå¤±æ•ˆã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆæˆ‘ä»¬è¦é™åˆ¶elevationçš„èŒƒå›´ã€‚

**æˆ‘ä»¬çš„è§£å†³æ–¹æ¡ˆï¼š**

```python
def orbit(self, dx, dy):
    """çƒåæ ‡è½¨é“æ—‹è½¬"""
    # æ–¹ä½è§’æ—‹è½¬ï¼ˆæ°´å¹³æ–¹å‘ï¼‰
    self.azimuth = (self.azimuth + dx * self.orbit_sensitivity) % 360.0
    
    # ä»°è§’æ—‹è½¬ï¼ˆå‚ç›´æ–¹å‘ï¼‰- å…³é”®é™åˆ¶
    self.elevation += dy * self.orbit_sensitivity
    self.elevation = max(-89.9, min(89.9, self.elevation))  # é¿å…ä¸‡å‘èŠ‚é”
```

é€šè¿‡å°†elevationé™åˆ¶åœ¨[-89.9Â°, 89.9Â°]èŒƒå›´å†…ï¼Œæˆ‘ä»¬æ°¸è¿œä¸ä¼šè¾¾åˆ°çœŸæ­£çš„ä¸‡å‘èŠ‚é”çŠ¶æ€ï¼ŒåŒæ—¶ä¿æŒäº†è¶³å¤Ÿçš„å‚ç›´è§†è§’èŒƒå›´ã€‚

#### 2.3.2 å±€éƒ¨åæ ‡ä¸ä¸–ç•Œåæ ‡

**ä¸ºä»€ä¹ˆæ—‹è½¬ä¼š"å¸¦ç€æ–¹å‘ä¸€èµ·æ—‹è½¬"ï¼Ÿ**

è¿™æ˜¯ç†è§£3Då›¾å½¢ç¼–ç¨‹çš„æ ¸å¿ƒæ¦‚å¿µä¹‹ä¸€ã€‚åœ¨è½¨é“ç›¸æœºçš„å¹³ç§»æ“ä½œä¸­ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ˜¯**å±€éƒ¨åæ ‡ç³»**è€Œéä¸–ç•Œåæ ‡ç³»ã€‚

**ä¸–ç•Œåæ ‡ç³»ï¼ˆWorld Spaceï¼‰ï¼š**
- å›ºå®šçš„å…¨å±€åæ ‡ç³»
- Xè½´å‘å³ï¼ŒYè½´å‘å‰ï¼ŒZè½´å‘ä¸Šï¼ˆåœ¨æˆ‘ä»¬çš„Z-Upç³»ç»Ÿä¸­ï¼‰
- æ‰€æœ‰ç‰©ä½“éƒ½åœ¨è¿™ä¸ªç»Ÿä¸€çš„åæ ‡ç³»ä¸­å®šä¹‰ä½ç½®

**ç›¸æœºå±€éƒ¨åæ ‡ç³»ï¼ˆCamera Spaceï¼‰ï¼š**
- ä»¥ç›¸æœºä¸ºåŸç‚¹çš„åæ ‡ç³»
- Forwardï¼šç›¸æœºè§‚å¯Ÿæ–¹å‘
- Rightï¼šç›¸æœºå³ä¾§æ–¹å‘  
- Upï¼šç›¸æœºä¸Šæ–¹æ–¹å‘

**å¹³ç§»ç®—æ³•ä¸­çš„åæ ‡å˜æ¢ï¼š**

```python
def pan(self, dx, dy, viewport_h):
    """å±å¹•ç©ºé—´å¹³ç§»"""
    if viewport_h <= 0:
        viewport_h = 1
    scale = self.distance * self.pan_sensitivity
    
    az = math.radians(self.azimuth)
    el = math.radians(self.elevation)
    
    # è®¡ç®—ç›¸æœºçš„å‰å‘å‘é‡
    forward = np.array([
        math.cos(el) * math.sin(az),
        math.cos(el) * math.cos(az), 
        math.sin(el)
    ], dtype=np.float32)
    
    # ä½¿ç”¨å›ºå®šçš„ä¸–ç•Œå‘ä¸Šå‘é‡è®¡ç®—å³å‘é‡
    world_up = np.array([0, 0, 1], dtype=np.float32)
    right = np.cross(forward, world_up)
    if np.linalg.norm(right) < 1e-8:
        right = np.array([1, 0, 0], dtype=np.float32)
    right /= np.linalg.norm(right)
    
    # è®¡ç®—ä¸Šå‘é‡ï¼ˆå‚ç›´äºforwardå’Œrightï¼‰
    up = np.cross(right, forward)
    up /= np.linalg.norm(up)
    
    # åº”ç”¨å¹³ç§» - å…³é”®ï¼šä½¿ç”¨å±€éƒ¨åæ ‡ç³»çš„å³å’Œä¸Šå‘é‡
    self.lookat -= right * dx * scale
    self.lookat += up * dy * scale
```

**ç›´è§‚ç†è§£"å¸¦ç€æ–¹å‘æ—‹è½¬"ï¼š**

1. å½“ä½ æ°´å¹³æ‹–åŠ¨é¼ æ ‡æ—¶ï¼Œä½ æœŸæœ›çš„æ˜¯åœ¨**å±å¹•ç©ºé—´**ä¸­å·¦å³å¹³ç§»
2. ä½†ç›¸æœºçš„"å³æ–¹å‘"åœ¨ä¸–ç•Œåæ ‡ç³»ä¸­æ˜¯éšç€ç›¸æœºæ—‹è½¬è€Œå˜åŒ–çš„
3. ç›¸æœºæœå‘æ­£å‰æ–¹æ—¶ï¼Œå³æ–¹å‘å°±æ˜¯ä¸–ç•Œåæ ‡çš„Xè½´
4. ç›¸æœºæ—‹è½¬90Â°åï¼Œå³æ–¹å‘å˜æˆäº†ä¸–ç•Œåæ ‡çš„-Yè½´
5. è¿™å°±æ˜¯"æ—‹è½¬å¸¦ç€æ–¹å‘ä¸€èµ·æ—‹è½¬"çš„æœ¬è´¨

**ä¸ºä»€ä¹ˆä½¿ç”¨å±€éƒ¨åæ ‡ç³»ï¼Ÿ**

**ä¼˜ç‚¹ï¼š**
- ç¬¦åˆç”¨æˆ·ç›´è§‰ï¼šå±å¹•ä¸Šçš„æ“ä½œå¯¹åº”å±å¹•ä¸Šçš„ç§»åŠ¨
- æ“ä½œä¸€è‡´æ€§ï¼šæ— è®ºç›¸æœºå¦‚ä½•æ—‹è½¬ï¼Œé¼ æ ‡æ“ä½œçš„æ•ˆæœéƒ½æ˜¯å¯é¢„æµ‹çš„
- æ›´è‡ªç„¶çš„äº¤äº’ï¼šç”¨æˆ·æ„Ÿè§‰æ˜¯åœ¨"ç§»åŠ¨ç”»é¢"è€Œé"åœ¨ä¸–ç•Œä¸­ç§»åŠ¨"

**ç¼ºç‚¹ï¼š**
- è®¡ç®—å¤æ‚ï¼šéœ€è¦å®æ—¶è®¡ç®—å±€éƒ¨åæ ‡è½´
- éœ€è¦ç†è§£åæ ‡å˜æ¢ï¼šå¯¹å¼€å‘è€…è¦æ±‚æ›´é«˜

**åæ ‡å˜æ¢çš„å¯è§†åŒ–ï¼š**

```
ä¸–ç•Œåæ ‡ç³»          ç›¸æœºå±€éƒ¨åæ ‡ç³»
    ^ Z                 ^ Up
    |                   |
    |                   |
    +---------> Y       +---------> Right
   /                  /
  /                  /
 V X               V Forward
```

**å®é™…åº”ç”¨åœºæ™¯ï¼š**

1. **è½¨é“æŸ¥çœ‹å™¨**ï¼šæˆ‘ä»¬çš„ç›¸æœºç³»ç»Ÿï¼Œç”¨æˆ·å›´ç»•ç‰©ä½“è§‚å¯Ÿ
2. **ç¬¬ä¸€äººç§°æ¸¸æˆ**ï¼šWASDç§»åŠ¨ä½¿ç”¨ä¸–ç•Œåæ ‡ï¼Œé¼ æ ‡ä½¿ç”¨å±€éƒ¨åæ ‡
3. **CADè½¯ä»¶**ï¼šé€šå¸¸ä½¿ç”¨ä¸–ç•Œåæ ‡è¿›è¡Œç²¾ç¡®å»ºæ¨¡
4. **é£è¡Œæ¨¡æ‹Ÿå™¨**ï¼šå¤æ‚çš„æ··åˆåæ ‡ç³»ç»Ÿ

é€šè¿‡ç†è§£è¿™äº›æ¦‚å¿µï¼Œä½ å¯ä»¥æ›´å¥½åœ°è®¾è®¡å’Œå®ç°3Dåº”ç”¨ä¸­çš„ç›¸æœºç³»ç»Ÿã€‚æˆ‘ä»¬çš„è½¨é“ç›¸æœºé€‰æ‹©å±€éƒ¨åæ ‡ç³»æ˜¯å› ä¸ºå®ƒæä¾›äº†æœ€ç›´è§‚çš„ç”¨æˆ·ä½“éªŒã€‚

### 2.4 æ ¸å¿ƒç»„ä»¶æ¶æ„

```
OrbitCameraï¼ˆç›¸æœºæ§åˆ¶å™¨ï¼‰
â”œâ”€â”€ ç›¸æœºå‚æ•°ç®¡ç†
â”‚   â”œâ”€â”€ azimuth: æ–¹ä½è§’
â”‚   â”œâ”€â”€ elevation: ä»°è§’  
â”‚   â”œâ”€â”€ distance: è§‚å¯Ÿè·ç¦»
â”‚   â”œâ”€â”€ lookat: è§‚å¯Ÿç›®æ ‡ç‚¹
â”‚   â””â”€â”€ fovy: è§†åœºè§’
â”œâ”€â”€ è§†è§’æ§åˆ¶ç®—æ³•
â”‚   â”œâ”€â”€ è‡ªåŠ¨é€‚é…ç®—æ³•
â”‚   â”œâ”€â”€ è½¨é“æ—‹è½¬ç®—æ³•
â”‚   â”œâ”€â”€ å¹³ç§»ç®—æ³•
â”‚   â””â”€â”€ ç¼©æ”¾ç®—æ³•
â”œâ”€â”€ äº¤äº’å¤„ç†é€»è¾‘
â”‚   â”œâ”€â”€ é¼ æ ‡äº‹ä»¶å¤„ç†
â”‚   â”œâ”€â”€ é”®ç›˜äº‹ä»¶å¤„ç†
â”‚   â””â”€â”€ æ»šè½®äº‹ä»¶å¤„ç†
â””â”€â”€ è‡ªé€‚åº”é€‚é…
    â”œâ”€â”€ è·ç¦»é™åˆ¶è°ƒæ•´
    â”œâ”€â”€ è£å‰ªå¹³é¢è°ƒæ•´
    â””â”€â”€ çµæ•åº¦è°ƒæ•´

MuJoCoWidgetï¼ˆæ¸²æŸ“ç»„ä»¶ï¼‰
â”œâ”€â”€ OpenGL åˆå§‹åŒ–
â”œâ”€â”€ MuJoCo é›†æˆ
â”œâ”€â”€ æ¸²æŸ“å¾ªç¯
â””â”€â”€ äº‹ä»¶åˆ†å‘

MainWindowï¼ˆä¸»çª—å£ï¼‰
â”œâ”€â”€ ç•Œé¢å¸ƒå±€
â”œâ”€â”€ ä¿¡å·è¿æ¥
â”œâ”€â”€ çŠ¶æ€ç®¡ç†
â””â”€â”€ ç”¨æˆ·äº¤äº’
```

### 2.3 ç±»ç»“æ„è®¾è®¡

#### 2.3.1 BaseCamera åŸºç±»
```python
class BaseCamera:
    """æ‰€æœ‰ç›¸æœºç±»å‹çš„åŸºç±»"""
    
    def __init__(self):
        self.position = np.array([0.0, 0.0, 1.0])
        self.target = np.array([0.0, 0.0, 0.0])
        self.up = np.array([0.0, 0.0, 1.0])
        self.fovy = 45.0
        self.aspect = 16.0 / 9.0
        self.near = 0.01
        self.far = 1000.0
        
    def get_view_matrix(self):
        """è·å–è§†å›¾çŸ©é˜µ"""
        return calculate_view_matrix(self.position, self.target, self.up)
    
    def get_projection_matrix(self):
        """è·å–æŠ•å½±çŸ©é˜µ"""
        return perspective_projection(self.fovy, self.aspect, self.near, self.far)
    
    def update(self, dt):
        """æ›´æ–°ç›¸æœºçŠ¶æ€ï¼ˆå­ç±»å®ç°ï¼‰"""
        pass
```

#### 2.4.1 OrbitCamera æ ¸å¿ƒç±»
```python
class OrbitCamera(BaseCamera):
    """è½¨é“ç›¸æœºæ§åˆ¶å™¨"""
    
    def __init__(self):
        super().__init__()
        
        # è½¨é“å‚æ•°
        self.azimuth = 90.0
        self.elevation = -30.0
        self.distance = 2.0
        self.lookat = np.array([0.0, 0.0, 0.0], dtype=np.float32)
        
        # æ§åˆ¶å‚æ•°
        self.orbit_sensitivity = 0.35    # æ—‹è½¬çµæ•åº¦
        self.pan_sensitivity = 0.0025    # å¹³ç§»çµæ•åº¦
        self.zoom_speed = 0.12           # ç¼©æ”¾é€Ÿåº¦
        self.fov_zoom_speed = 0.10       # FOVç¼©æ”¾é€Ÿåº¦
        
        # èŒƒå›´é™åˆ¶
        self.min_distance = 0.001
        self.max_distance = 100.0
        self.min_fovy = 5.0
        self.max_fovy = 90.0
        
        # æ ¸å¿ƒæ–¹æ³•
        # - fit(): è‡ªåŠ¨é€‚é…æ¨¡å‹
        # - orbit(): è½¨é“æ—‹è½¬
        # - pan(): å¹³ç§»
        # - dolly(): è·ç¦»ç¼©æ”¾
        # - zoom_fov(): è§†åœºè§’ç¼©æ”¾
```

---

## 3. æ ¸å¿ƒç®—æ³•è®¾è®¡

### 3.1 æ•°å­¦åŸºç¡€

#### 3.1.1 åæ ‡ç³»ç»Ÿå®šä¹‰
```python
# æ¨èçš„åæ ‡ç³»ç»Ÿå®šä¹‰
WORLD_UP = np.array([0, 0, 1])  # Z-Up (MuJoCoé£æ ¼)
WORLD_FORWARD = np.array([1, 0, 0])  # X-Forward
WORLD_RIGHT = np.array([0, 1, 0])  # Y-Right
```

#### 3.1.2 çƒé¢åæ ‡è½¬æ¢
```python
def spherical_to_cartesian(azimuth, elevation, distance):
    """çƒé¢åæ ‡è½¬ç¬›å¡å°”åæ ‡"""
    az_rad = math.radians(azimuth)
    el_rad = math.radians(elevation)
    
    x = distance * math.cos(el_rad) * math.sin(az_rad)
    y = distance * math.cos(el_rad) * math.cos(az_rad)
    z = distance * math.sin(el_rad)
    
    return np.array([x, y, z])

def cartesian_to_spherical(position):
    """ç¬›å¡å°”åæ ‡è½¬çƒé¢åæ ‡"""
    distance = np.linalg.norm(position)
    azimuth = math.degrees(math.atan2(position[0], position[1]))
    elevation = math.degrees(math.asin(position[2] / distance))
    return azimuth, elevation, distance
```

### 3.2 è‡ªåŠ¨é€‚é…ç®—æ³•

```python
def fit(self, model):
    """åŸºäºæ¨¡å‹ç»Ÿè®¡ä¿¡æ¯è‡ªåŠ¨é€‚é…è§†è§’"""
    # è·å–æ¨¡å‹å°ºå¯¸å’Œä¸­å¿ƒç‚¹
    extent = model.stat.extent
    center = np.array(model.stat.center, dtype=np.float32)
    
    # è®¡ç®—æœ€ä½³è§‚å¯Ÿè·ç¦»
    # distance = extent / (2 * tan(fovy/2)) * 1.2
    half_fov_rad = math.radians(self.fovy) / 2.0
    base = extent / (2.0 * math.tan(half_fov_rad) + 1e-9)
    self.distance = base * 1.2  # ç•™å‡ºè¾¹è·
    
    # è®¾ç½®è§‚å¯Ÿç›®æ ‡
    self.lookat[:] = center
    
    # åŠ¨æ€è°ƒæ•´èŒƒå›´é™åˆ¶
    self.min_distance = max(extent * 0.01, 0.0005)
    self.max_distance = extent * 20.0
```

### 3.3 è½¨é“æ—‹è½¬ç®—æ³•

```python
def orbit(self, dx, dy):
    """çƒåæ ‡è½¨é“æ—‹è½¬"""
    # æ–¹ä½è§’æ—‹è½¬ï¼ˆæ°´å¹³æ–¹å‘ï¼‰
    self.azimuth = (self.azimuth + dx * self.orbit_sensitivity) % 360.0
    
    # ä»°è§’æ—‹è½¬ï¼ˆå‚ç›´æ–¹å‘ï¼‰
    self.elevation += dy * self.orbit_sensitivity
    self.elevation = max(-89.9, min(89.9, self.elevation))
```

### 3.4 å¹³ç§»ç®—æ³•

```python
def pan(self, dx, dy, viewport_h):
    """å±å¹•ç©ºé—´å¹³ç§»"""
    if viewport_h <= 0:
        viewport_h = 1
    
    # æ ¹æ®è·ç¦»è°ƒæ•´å¹³ç§»çµæ•åº¦
    scale = self.distance * self.pan_sensitivity
    
    # è®¡ç®—ç›¸æœºåæ ‡ç³»
    az = math.radians(self.azimuth)
    el = math.radians(self.elevation)
    
    # å‰æ–¹å‘
    forward = np.array([
        math.cos(el) * math.sin(az),
        math.cos(el) * math.cos(az),
        math.sin(el)
    ], dtype=np.float32)
    
    # æ„å»ºç›¸æœºåæ ‡ç³»
    world_up = np.array([0, 0, 1], dtype=np.float32)
    right = np.cross(forward, world_up)
    if np.linalg.norm(right) < 1e-8:
        right = np.array([1, 0, 0], dtype=np.float32)
    right /= np.linalg.norm(right)
    
    up = np.cross(right, forward)
    up /= np.linalg.norm(up)
    
    # åº”ç”¨å¹³ç§»
    self.lookat -= right * dx * scale
    self.lookat += up * dy * scale
```

### 3.5 ç¼©æ”¾ç®—æ³•

#### 3.5.1 è·ç¦»ç¼©æ”¾ï¼ˆæŒ‡æ•°ç¼©æ”¾ï¼‰
```python
def dolly(self, scroll_steps):
    """æŒ‡æ•°ç¼©æ”¾ç®—æ³•"""
    # ä½¿ç”¨æŒ‡æ•°å‡½æ•°å®ç°å¹³æ»‘ç¼©æ”¾
    factor = math.exp(-self.zoom_speed * scroll_steps)
    self.distance *= factor
    
    # é™åˆ¶ç¼©æ”¾èŒƒå›´
    self.distance = max(self.min_distance, min(self.max_distance, self.distance))
```

#### 3.5.2 è§†åœºè§’ç¼©æ”¾
```python
def zoom_fov(self, scroll_steps):
    """è§†åœºè§’ç¼©æ”¾"""
    factor = math.exp(-self.fov_zoom_speed * scroll_steps)
    self.fovy *= factor
    self.fovy = max(self.min_fovy, min(self.max_fovy, self.fovy))
```

### 3.6 åŠ¨æ€è£å‰ªå¹³é¢è°ƒæ•´

```python
def update_clip_planes(self, model):
    """æ›´æ–°è£å‰ªå¹³é¢"""
    if hasattr(model, "vis"):
        # åŠ¨æ€è°ƒæ•´è¿‘è£å‰ªé¢ï¼Œé¿å…æ·±åº¦å†²çª
        znear = max(1e-4, self.distance * 0.01)
        model.vis.map.znear = float(znear)
```

---

## 4. äº¤äº’ç³»ç»Ÿè®¾è®¡

### 4.1 äº¤äº’æ¨¡å¼è®¾è®¡

| æ¨¡å¼ | è§¦å‘æ–¹å¼ | å®ç°å¤æ‚åº¦ | ç”¨æˆ·å‹å¥½åº¦ | é€‚ç”¨åœºæ™¯ |
|------|----------|------------|------------|----------|
| å•æ¨¡å¼ | æ‰€æœ‰æ“ä½œéƒ½ä¸€æ · | ä½ | æœ‰é™ | ç®€å•åº”ç”¨ |
| **å¤šé”®æ¨¡å¼** âœ“ | ä¸åŒæŒ‰é”®ä¸åŒåŠŸèƒ½ | ä¸­ | ä¸“ä¸šç”¨æˆ·å‹å¥½ | ä¸“ä¸šè½¯ä»¶ |
| ä¸Šä¸‹æ–‡æ¨¡å¼ | æ ¹æ®çŠ¶æ€è‡ªåŠ¨åˆ‡æ¢ | é«˜ | å­¦ä¹ æˆæœ¬é«˜ | æ™ºèƒ½ç³»ç»Ÿ |
| æ‰‹åŠ¿æ¨¡å¼ | å¤šæŒ‡è§¦æ§ | ä¸­ | ç§»åŠ¨è®¾å¤‡ | ç§»åŠ¨åº”ç”¨ |

**é€‰æ‹©ç†ç”±**ï¼šä¸“ä¸š3Dè½¯ä»¶ç”¨æˆ·ä¹ æƒ¯å¤šé”®æ¨¡å¼ï¼ŒåŠŸèƒ½ä¸°å¯Œä¸”å­¦ä¹ æˆæœ¬åˆç†ã€‚

### 4.2 é¼ æ ‡äº¤äº’æ˜ å°„

| æ“ä½œ | æ–¹å¼ | å®ç°åŸç† | ç”¨æˆ·ä½“éªŒ |
|------|------|----------|----------|
| **æ—‹è½¬** | å·¦é”®æ‹–åŠ¨ | çƒé¢åæ ‡æ–¹ä½è§’/ä¿¯ä»°è§’ | ç›´è§‚çš„è½¨é“æ—‹è½¬ |
| **å¹³ç§»** | å³é”®/Shift+å·¦é”® | å±å¹•ç©ºé—´å‘é‡æŠ•å½± | ç²¾ç¡®çš„ä½ç½®è°ƒæ•´ |
| **ç¼©æ”¾** | æ»šè½® | æŒ‡æ•°è·ç¦»ç¼©æ”¾ | è‡ªç„¶çš„æ·±åº¦æ„Ÿ |
| **FOVè°ƒæ•´** | Ctrl+æ»šè½® | è§†åœºè§’è°ƒæ•´ | ç±»ä¼¼é•œå¤´å˜ç„¦ |
| **é‡ç½®** | åŒå‡»/Fé”® | fit()è‡ªåŠ¨è´´åˆ | å¿«é€Ÿå›åˆ°æœ€ä½³è§†è§’ |

### 4.3 è¾“å…¥å¤„ç†ç³»ç»Ÿ

#### 4.3.1 è¾“å…¥å¤„ç†å™¨
```python
class InputHandler:
    """ç»Ÿä¸€è¾“å…¥å¤„ç†"""
    
    def __init__(self):
        self.mouse_pos = None
        self.last_mouse_pos = None
        self.mouse_buttons = {}
        self.keyboard_modifiers = {}
        self.scroll_delta = 0
        
    def handle_mouse_press(self, event):
        """å¤„ç†é¼ æ ‡æŒ‰ä¸‹"""
        self.mouse_buttons[event.button()] = True
        self.mouse_pos = event.position()
        self.last_mouse_pos = self.mouse_pos
        
    def handle_mouse_release(self, event):
        """å¤„ç†é¼ æ ‡é‡Šæ”¾"""
        self.mouse_buttons[event.button()] = False
        
    def handle_mouse_move(self, event):
        """å¤„ç†é¼ æ ‡ç§»åŠ¨"""
        self.last_mouse_pos = self.mouse_pos
        self.mouse_pos = event.position()
        
    def handle_scroll(self, event):
        """å¤„ç†æ»šè½®"""
        self.scroll_delta = event.angleDelta().y() / 120.0
        
    def get_mouse_delta(self):
        """è·å–é¼ æ ‡ç§»åŠ¨å¢é‡"""
        if self.mouse_pos and self.last_mouse_pos:
            return self.mouse_pos - self.last_mouse_pos
        return None
```

#### 4.3.2 äº¤äº’æ˜ å°„å™¨
```python
class InteractionMapper:
    """äº¤äº’æ¨¡å¼æ˜ å°„"""
    
    def __init__(self, camera, input_handler):
        self.camera = camera
        self.input = input_handler
        
    def update(self):
        """æ›´æ–°äº¤äº’"""
        mouse_delta = self.input.get_mouse_delta()
        if mouse_delta is None:
            return
            
        dx, dy = mouse_delta.x(), mouse_delta.y()
        
        # åˆ¤æ–­äº¤äº’æ¨¡å¼å¹¶æ‰§è¡Œç›¸åº”æ“ä½œ
        if self._is_orbit_mode():
            self.camera.orbit(dx, dy)
        elif self._is_pan_mode():
            viewport_height = 600  # åº”è¯¥ä»æ¸²æŸ“å™¨è·å–
            self.camera.pan(dx, dy, viewport_height)
            
        # å¤„ç†æ»šè½®
        if self.input.scroll_delta != 0:
            if self._is_zoom_fov_mode():
                self.camera.zoom_fov(self.input.scroll_delta)
            else:
                self.camera.dolly(self.input.scroll_delta)
            self.input.scroll_delta = 0
            
    def _is_orbit_mode(self):
        """åˆ¤æ–­æ˜¯å¦ä¸ºè½¨é“æ¨¡å¼"""
        left_pressed = self.input.mouse_buttons.get(Qt.LeftButton, False)
        right_pressed = self.input.mouse_buttons.get(Qt.RightButton, False)
        shift_pressed = Qt.ShiftModifier in self.input.keyboard_modifiers
        
        return left_pressed and not right_pressed and not shift_pressed
        
    def _is_pan_mode(self):
        """åˆ¤æ–­æ˜¯å¦ä¸ºå¹³ç§»æ¨¡å¼"""
        left_pressed = self.input.mouse_buttons.get(Qt.LeftButton, False)
        right_pressed = self.input.mouse_buttons.get(Qt.RightButton, False)
        shift_pressed = Qt.ShiftModifier in self.input.keyboard_modifiers
        
        return (left_pressed and shift_pressed) or right_pressed
        
    def _is_zoom_fov_mode(self):
        """åˆ¤æ–­æ˜¯å¦ä¸ºFOVç¼©æ”¾æ¨¡å¼"""
        return Qt.ControlModifier in self.input.keyboard_modifiers
```

### 4.4 é”®ç›˜å¿«æ·é”®

| æŒ‰é”® | åŠŸèƒ½ | å®ç°æ–¹å¼ | ä¼˜å…ˆçº§ |
|------|------|----------|--------|
| **ç©ºæ ¼** | å¼€å§‹/æš‚åœä»¿çœŸ | toggle_sim() | é«˜ |
| **R/F** | é‡ç½®ç›¸æœºè§†è§’ | fit(model) | é«˜ |
| **ESC** | é€€å‡ºåº”ç”¨ | close() | ä¸­ |
| **WASD** | é¢å¤–å¹³ç§»æ§åˆ¶ | è‡ªå®šä¹‰æ‰©å±• | ä½ |

### 4.5 å‚æ•°è°ƒèŠ‚

```python
# çµæ•åº¦å‚æ•°ï¼ˆå¯æ ¹æ®ç”¨æˆ·ä¹ æƒ¯è°ƒæ•´ï¼‰
self.orbit_sensitivity = 0.35    # æ—‹è½¬é€Ÿåº¦ (è§’åº¦/åƒç´ )
self.pan_sensitivity = 0.0025    # å¹³ç§»é€Ÿåº¦ (æ¯”ä¾‹ * distance)  
self.zoom_speed = 0.12           # ç¼©æ”¾é€Ÿåº¦ (æŒ‡æ•°ç³»æ•°)
self.fov_zoom_speed = 0.10       # è§†åœºè§’ç¼©æ”¾é€Ÿåº¦

# èŒƒå›´é™åˆ¶
self.min_distance = 0.001       # æœ€å°è·ç¦»
self.max_distance = 100.0        # æœ€å¤§è·ç¦»
self.min_fovy = 5.0              # æœ€å°è§†åœºè§’
self.max_fovy = 90.0             # æœ€å¤§è§†åœºè§’
self.min_elevation = -89.9       # æœ€å°ä»°è§’
self.max_elevation = 89.9        # æœ€å¤§ä»°è§’
```

---

## 5. MuJoCo é›†æˆè®¾è®¡

### 5.1 ç›¸æœºåŒæ­¥æœºåˆ¶

#### 5.1.1 MuJoCo ç›¸æœºåº”ç”¨
```python
def apply_to_mjcam(self, mjcam):
    """åº”ç”¨åˆ°MuJoCoç›¸æœº"""
    mjcam.type = mujoco.mjtCamera.mjCAMERA_FREE
    mjcam.azimuth = self.azimuth
    mjcam.elevation = self.elevation
    mjcam.distance = self.distance
    mjcam.lookat[:] = self.lookat
    
    # FOV éœ€è¦é€šè¿‡ model.vis.global.fovy è®¾ç½®
    if hasattr(self.model, 'vis') and hasattr(self.model.vis, 'global'):
        self.model.vis.global.fovy = self.fovy
```

#### 5.1.2 MuJoCo æ¸²æŸ“é›†æˆ
```python
def paintGL(self):
    """MuJoCoæ¸²æŸ“å¾ªç¯"""
    if self.model is None:
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
        return

    # è¿è¡Œä»¿çœŸ
    if self.is_running:
        self.step_sim()

    # åŒæ­¥ç›¸æœºå‚æ•°
    self.cam.apply_to_mjcam(self.mjcam)
    self.cam.update_clip_planes(self.model)

    # è®¾ç½®è§†å£
    viewport = mujoco.MjrRect(0, 0, self.width(), self.height())

    # æ›´æ–°å’Œæ¸²æŸ“åœºæ™¯
    mujoco.mjv_updateScene(
        self.model, self.data, self.opt,
        None, self.mjcam, mujoco.mjtCatBit.mjCAT_ALL, self.scene
    )
    mujoco.mjr_render(viewport, self.scene, self.mjr_context)
```

### 5.2 ä»¿çœŸåŒæ­¥ä¼˜åŒ–

#### 5.2.1 å¤šæ­¥ä»¿çœŸä¿è¯æ—¶é—´åŒæ­¥
```python
def step_sim(self, dt_target=1/60.0):
    """å¤šæ­¥ä»¿çœŸä¿è¯æ—¶é—´åŒæ­¥"""
    if self.model is None:
        return
        
    start = self.data.time
    steps = 0
    max_steps = 400  # é˜²æ­¢æ— é™å¾ªç¯
    
    while (self.data.time - start) < dt_target and steps < max_steps:
        if self.model.nu > 0:
            ctrl = np.zeros(self.model.nu)
            # å¯æŒ‰éœ€è®¾ç½®åŠ¨ä½œ
            self.data.ctrl[:] = ctrl
        mujoco.mj_step(self.model, self.data)
        steps += 1
        
    self.simulation_time = self.data.time
```

### 5.3 èµ„æºç®¡ç†

#### 5.3.1 é¢„åˆ†é…æ¸²æŸ“èµ„æº
```python
def initializeGL(self):
    """åˆå§‹åŒ–OpenGLå’ŒMuJoCoèµ„æº"""
    if self.model is None:
        glClearColor(0.15, 0.0, 0.0, 1.0)
        return
        
    # é¢„åˆ†é…åœºæ™¯å¯¹è±¡ï¼Œé¿å…æ¯å¸§é‡æ–°åˆ†é…
    self.scene = mujoco.MjvScene(self.model, maxgeom=20000)
    self.mjr_context = mujoco.MjrContext(self.model, mujoco.mjtFontScale.mjFONTSCALE_150)
    self.mjcam = mujoco.MjvCamera()
    self.opt = mujoco.MjvOption()
    
    # åˆå§‹åŒ–é»˜è®¤å€¼
    mujoco.mjv_defaultCamera(self.mjcam)
    mujoco.mjv_defaultOption(self.opt)
    
    # å¯ç”¨æ·±åº¦æµ‹è¯•
    glEnable(GL_DEPTH_TEST)
    
    # åº”ç”¨åˆå§‹ç›¸æœºå‚æ•°
    self.cam.apply_to_mjcam(self.mjcam)
    self.cam.update_clip_planes(self.model)
```

---

## 6. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 6.1 æ¸²æŸ“ä¼˜åŒ–çº§åˆ«

| çº§åˆ« | ç­–ç•¥ | æ•ˆæœ | å®ç°æˆæœ¬ | æ¨èåº¦ |
|------|------|------|----------|--------|
| **åŸºç¡€ä¼˜åŒ–** âœ“ | å‡å°‘draw callã€é¢„åˆ†é…èµ„æº | 20-30%æå‡ | ä½ | â­â­â­â­â­ |
| **ä¸­çº§ä¼˜åŒ–** âœ“ | è§†é”¥å‰”é™¤ã€åŠ¨æ€znear | 40-60%æå‡ | ä¸­ | â­â­â­â­â­ |
| é«˜çº§ä¼˜åŒ– | LODç³»ç»Ÿã€é®æŒ¡å‰”é™¤ | 2-5å€æå‡ | é«˜ | â­â­â­â˜†â˜† |
| æè‡´ä¼˜åŒ– | GPU Instancingã€æ‰¹å¤„ç† | 5-10å€æå‡ | å¾ˆé«˜ | â­â­â˜†â˜†â˜† |

**é€‰æ‹©åŸºç¡€+ä¸­çº§**ï¼šåœ¨å®ç°æˆæœ¬å’Œæ•ˆæœé—´å¹³è¡¡ï¼Œé€‚åˆå¤§å¤šæ•°åº”ç”¨ã€‚

### 6.2 å†…å­˜ç®¡ç†ç­–ç•¥

#### 6.2.1 é¢„åˆ†é…å¤ç”¨ç­–ç•¥
```python
# ç­–ç•¥1ï¼šæ¯å¸§é‡æ–°åˆ†é…ï¼ˆç®€å•ä½†ä½æ•ˆï¼‰
def render():
    scene = mujoco.MjvScene(model, maxgeom=1000)  # æ¯å¸§åˆ†é…

# ç­–ç•¥2ï¼šé¢„åˆ†é…å¤ç”¨ï¼ˆæ¨èï¼‰
def __init__(self):
    self.scene = mujoco.MjvScene(model, maxgeom=20000)  # ä¸€æ¬¡åˆ†é…

# ç­–ç•¥3ï¼šåŠ¨æ€è°ƒæ•´ï¼ˆé«˜çº§ï¼‰
def update_scene_size(self):
    new_size = estimate_required_geoms()
    if new_size != self.scene.maxgeom:
        self.scene = mujoco.MjvScene(model, maxgeom=new_size)
```

**é€‰æ‹©é¢„åˆ†é…**ï¼šé¿å…æ¯å¸§å†…å­˜åˆ†é…ï¼Œæä¾›ç¨³å®šçš„æ€§èƒ½ã€‚

### 6.3 æ¸²æŸ“ä¼˜åŒ–æŠ€æœ¯

#### 6.3.1 è§†é”¥å‰”é™¤
```python
class FrustumCulling:
    """è§†é”¥å‰”é™¤ä¼˜åŒ–"""
    
    def should_render(self, bounds, camera):
        """åˆ¤æ–­è¾¹ç•Œæ¡†æ˜¯å¦åœ¨è§†é”¥å†…"""
        if not self.frustum_culling_enabled:
            return True
            
        # è®¡ç®—è¾¹ç•Œçƒæ˜¯å¦åœ¨è§†é”¥å†…
        camera_pos = camera.position
        distance = np.linalg.norm(bounds.center - camera_pos)
        
        # ç®€åŒ–çš„è·ç¦»å‰”é™¤
        return distance < camera.far
```

#### 6.3.2 å»¶è¿Ÿæ¸²æŸ“æŠ€æœ¯
```python
class OptimizedRenderer:
    """ä¼˜åŒ–çš„æ¸²æŸ“å™¨"""
    
    def __init__(self):
        self.needs_update = True
        self.update_timer = QTimer()
        self.update_timer.timeout.connect(self.trigger_update)
        self.update_timer.setSingleShot(True)
        
    def schedule_update(self):
        """å»¶è¿Ÿæ¸²æŸ“æ›´æ–°"""
        if not self.update_timer.isActive():
            self.update_timer.start(16)  # 16msåæ›´æ–°
            
    def trigger_update(self):
        """è§¦å‘å®é™…æ›´æ–°"""
        self.needs_update = True
        self.update()
```

### 6.4 äº¤äº’ä¼˜åŒ–

#### 6.4.1 äº‹ä»¶èŠ‚æµ
```python
def mouseMoveEvent(self, event):
    """äº‹ä»¶èŠ‚æµæ§åˆ¶"""
    current_time = time.time()
    if hasattr(self, 'last_update_time'):
        if current_time - self.last_update_time < 0.016:  # 60 FPSé™åˆ¶
            return
    self.last_update_time = current_time
    
    # å¤„ç†äº‹ä»¶
    self.handle_mouse_move(event)
```

#### 6.4.2 å“åº”æ€§è®¾è®¡ç›®æ ‡

| æ“ä½œ | ç›®æ ‡å“åº”æ—¶é—´ | ä¼˜åŒ–ç­–ç•¥ | é‡è¦æ€§ |
|------|-------------|----------|--------|
| **é¼ æ ‡ç§»åŠ¨** | < 16ms (60FPS) | å‡å°‘è®¡ç®—é‡ã€äº‹ä»¶èŠ‚æµ | é«˜ |
| **æ»šè½®ç¼©æ”¾** | < 32ms | é¢„è®¡ç®—å¸¸ç”¨å€¼ | é«˜ |
| **é”®ç›˜è¾“å…¥** | < 50ms | äº‹ä»¶ç¼“å†² | ä¸­ |
| **æ¨¡å‹åŠ è½½** | < 1000ms | å¼‚æ­¥åŠ è½½ã€è¿›åº¦æ˜¾ç¤º | ä¸­ |

---

## 7. é›†æˆæŒ‡å—

### 7.1 åŸºç¡€é›†æˆæ­¥éª¤

#### 7.1.1 æœ€å°é›†æˆç¤ºä¾‹
```python
#!/usr/bin/env python3
import sys
import math
import numpy as np
import mujoco
from PySide6.QtWidgets import QApplication, QMainWindow
from PySide6.QtCore import QTimer, Qt
from PySide6.QtOpenGLWidgets import QOpenGLWidget
from OpenGL.GL import *

# 1. å¯¼å…¥æˆ–å¤åˆ¶OrbitCameraç±»
class OrbitCamera:
    """è½¨é“ç›¸æœºæ§åˆ¶å™¨ï¼ˆå®Œæ•´å®ç°è§ç¬¬3ç« ï¼‰"""
    pass

# 2. åˆ›å»ºé›†æˆç»„ä»¶
class MuJoCoCameraWidget(QOpenGLWidget):
    """é›†æˆè½¨é“ç›¸æœºçš„MuJoCoæ¸²æŸ“ç»„ä»¶"""
    
    def __init__(self, model_path):
        super().__init__()
        self.setFocusPolicy(Qt.StrongFocus)
        
        # åŠ è½½æ¨¡å‹
        self.model = mujoco.MjModel.from_xml_path(model_path)
        self.data = mujoco.MjData(self.model)
        mujoco.mj_forward(self.model, self.data)
        
        # åˆå§‹åŒ–ç›¸æœº
        self.camera = OrbitCamera()
        self.camera.fit(self.model)
        
        # åˆå§‹åŒ–æ¸²æŸ“èµ„æº
        self.init_rendering()
        
        # è®¾ç½®æ›´æ–°å¾ªç¯
        self.timer = QTimer()
        self.timer.timeout.connect(self.update)
        self.timer.start(16)
    
    def init_rendering(self):
        """åˆå§‹åŒ–æ¸²æŸ“èµ„æº"""
        self.scene = mujoco.MjvScene(self.model, maxgeom=20000)
        self.mjr_context = mujoco.MjrContext(self.model, mujoco.mjtFontScale.mjFONTSCALE_150)
        self.mjcam = mujoco.MjvCamera()
        self.opt = mujoco.MjvOption()
        
        mujoco.mjv_defaultCamera(self.mjcam)
        mujoco.mjv_defaultOption(self.opt)
        
    def initializeGL(self):
        glEnable(GL_DEPTH_TEST)
        self.camera.apply_to_mjcam(self.mjcam)
        self.camera.update_clip_planes(self.model)
    
    def paintGL(self):
        # æ›´æ–°ç›¸æœº
        self.camera.apply_to_mjcam(self.mjcam)
        self.camera.update_clip_planes(self.model)
        
        # æ¸²æŸ“åœºæ™¯
        viewport = mujoco.MjrRect(0, 0, self.width(), self.height())
        mujoco.mjv_updateScene(
            self.model, self.data, self.opt,
            None, self.mjcam, mujoco.mjtCatBit.mjCAT_ALL, self.scene
        )
        mujoco.mjr_render(viewport, self.scene, self.mjr_context)
    
    # äº‹ä»¶å¤„ç†æ–¹æ³•
    def mousePressEvent(self, event): pass
    def mouseMoveEvent(self, event): pass
    def wheelEvent(self, event): pass
    def keyPressEvent(self, event): pass

# 3. ä½¿ç”¨ç¤ºä¾‹
def main():
    app = QApplication(sys.argv)
    
    window = QMainWindow()
    window.setWindowTitle("MuJoCo é€šç”¨è½¨é“ç›¸æœºç¤ºä¾‹")
    window.resize(1200, 800)
    
    # åˆ›å»ºç›¸æœºç»„ä»¶
    model_path = "your_model.xml"  # æ›¿æ¢ä¸ºæ‚¨çš„æ¨¡å‹è·¯å¾„
    camera_widget = MuJoCoCameraWidget(model_path)
    window.setCentralWidget(camera_widget)
    
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

### 7.2 è‡ªå®šä¹‰æ‰©å±•

#### 7.2.1 è‡ªå®šä¹‰ç›¸æœºå‚æ•°
```python
class CustomOrbitCamera(OrbitCamera):
    """è‡ªå®šä¹‰è½¨é“ç›¸æœº"""
    
    def __init__(self):
        super().__init__()
        # è‡ªå®šä¹‰å‚æ•°
        self.orbit_sensitivity = 0.5    # æ›´å¿«çš„æ—‹è½¬
        self.zoom_speed = 0.2         # æ›´å¿«çš„ç¼©æ”¾
        self.smoothing_enabled = True  # å¯ç”¨å¹³æ»‘
        
    def update_with_smoothing(self, dt):
        """å¸¦å¹³æ»‘çš„æ›´æ–°"""
        if self.smoothing_enabled:
            # å®ç°å¹³æ»‘è¿‡æ¸¡é€»è¾‘
            smoothing_factor = 0.1
            # ... å¹³æ»‘ç®—æ³•å®ç°
        super().update(dt)
```

#### 7.2.2 æ·»åŠ æ–°åŠŸèƒ½
```python
class ExtendedOrbitCamera(OrbitCamera):
    """æ‰©å±•åŠŸèƒ½ç›¸æœº"""
    
    def __init__(self):
        super().__init__()
        self.animation_system = AnimationSystem(self)
        self.viewpoint_manager = ViewpointManager(self)
        
    def save_current_view(self, name):
        """ä¿å­˜å½“å‰è§†è§’"""
        self.viewpoint_manager.save_viewpoint(name)
        
    def restore_view(self, name):
        """æ¢å¤ä¿å­˜çš„è§†è§’"""
        self.viewpoint_manager.restore_viewpoint(name)
        
    def animate_to_view(self, target_params, duration=1.0):
        """åŠ¨ç”»è¿‡æ¸¡åˆ°ç›®æ ‡è§†è§’"""
        self.animation_system.add_animation(target_params, duration)
```

### 7.3 é«˜çº§åŠŸèƒ½é›†æˆ

#### 7.3.1 åŠ¨ç”»ç³»ç»Ÿ
```python
class AnimationSystem:
    """ç›¸æœºåŠ¨ç”»ç³»ç»Ÿ"""
    
    def __init__(self, camera):
        self.camera = camera
        self.animations = []
        
    def add_animation(self, target_params, duration=1.0, curve_type="ease_in_out"):
        """æ·»åŠ ç›¸æœºåŠ¨ç”»"""
        animation = {
            'start_params': self._get_current_params(),
            'target_params': target_params,
            'duration': duration,
            'curve_type': curve_type,
            'progress': 0.0
        }
        self.animations.append(animation)
        
    def update(self, dt):
        """æ›´æ–°åŠ¨ç”»"""
        for animation in self.animations[:]:
            animation['progress'] += dt / animation['duration']
            
            if animation['progress'] >= 1.0:
                # åŠ¨ç”»å®Œæˆ
                self._apply_params(animation['target_params'])
                self.animations.remove(animation)
            else:
                # æ’å€¼å½“å‰å‚æ•°
                t = self._apply_curve(animation['progress'], animation['curve_type'])
                current_params = self._interpolate_params(
                    animation['start_params'], 
                    animation['target_params'], 
                    t
                )
                self._apply_params(current_params)
                
    def _apply_curve(self, t, curve_type):
        """åº”ç”¨ç¼“åŠ¨æ›²çº¿"""
        if curve_type == "linear":
            return t
        elif curve_type == "ease_in_out":
            return 3*t**2 - 2*t**3
        elif curve_type == "ease_in":
            return t**2
        elif curve_type == "ease_out":
            return 1 - (1-t)**2
        return t
```

#### 7.3.2 å¤šè§†è§’ç®¡ç†
```python
class ViewpointManager:
    """å¤šè§†è§’ç®¡ç†å™¨"""
    
    def __init__(self, camera):
        self.camera = camera
        self.viewpoints = {}
        
    def save_viewpoint(self, name):
        """ä¿å­˜å½“å‰è§†è§’"""
        self.viewpoints[name] = {
            'azimuth': self.camera.azimuth,
            'elevation': self.camera.elevation,
            'distance': self.camera.distance,
            'lookat': self.camera.lookat.copy(),
            'fovy': self.camera.fovy
        }
        
    def load_viewpoint(self, name):
        """åŠ è½½ä¿å­˜çš„è§†è§’"""
        if name in self.viewpoints:
            vp = self.viewpoints[name]
            self.camera.azimuth = vp['azimuth']
            self.camera.elevation = vp['elevation']
            self.camera.distance = vp['distance']
            self.camera.lookat[:] = vp['lookat']
            self.camera.fovy = vp['fovy']
            
    def list_viewpoints(self):
        """åˆ—å‡ºæ‰€æœ‰ä¿å­˜çš„è§†è§’"""
        return list(self.viewpoints.keys())
```

---

## 8. å®Œæ•´å®ç°ä»£ç 

### 8.1 æ ¸å¿ƒå®ç°

```python
#!/usr/bin/env python3
"""
MuJoCo é€šç”¨è½¨é“ç›¸æœºç³»ç»Ÿ
å®Œæ•´å®ç°ï¼Œå¯ç›´æ¥å¤åˆ¶ä½¿ç”¨
"""

import sys
import math
import numpy as np
import mujoco
from PySide6.QtWidgets import QApplication, QMainWindow, QWidget
from PySide6.QtCore import QTimer, Qt
from PySide6.QtOpenGLWidgets import QOpenGLWidget
from OpenGL.GL import *

class OrbitCamera:
    """é€šç”¨è½¨é“ç›¸æœºæ§åˆ¶å™¨"""
    
    def __init__(self):
        # ç›¸æœºå‚æ•°
        self.azimuth = 90.0
        self.elevation = -30.0
        self.distance = 2.0
        self.lookat = np.array([0.0, 0.0, 0.0], dtype=np.float32)
        self.fovy = 45.0
        
        # æ§åˆ¶å‚æ•°
        self.orbit_sensitivity = 0.35
        self.pan_sensitivity = 0.0025
        self.zoom_speed = 0.12
        self.fov_zoom_speed = 0.10
        
        # èŒƒå›´é™åˆ¶
        self.min_distance = 0.001
        self.max_distance = 100.0
        self.min_fovy = 5.0
        self.max_fovy = 90.0
    
    def fit(self, model):
        """è‡ªåŠ¨é€‚é…æ¨¡å‹"""
        extent = model.stat.extent
        center = np.array(model.stat.center, dtype=np.float32)
        self.lookat[:] = center
        
        half_fov_rad = math.radians(self.fovy) / 2.0
        base = extent / (2.0 * math.tan(half_fov_rad) + 1e-9)
        self.distance = base * 1.2
        
        self.min_distance = max(extent * 0.01, 0.0005)
        self.max_distance = extent * 20.0
    
    def apply_to_mjcam(self, mjcam):
        """åº”ç”¨åˆ°MuJoCoç›¸æœº"""
        mjcam.type = mujoco.mjtCamera.mjCAMERA_FREE
        mjcam.azimuth = self.azimuth
        mjcam.elevation = self.elevation
        mjcam.distance = self.distance
        mjcam.lookat[:] = self.lookat
    
    def orbit(self, dx, dy):
        """è½¨é“æ—‹è½¬"""
        self.azimuth = (self.azimuth + dx * self.orbit_sensitivity) % 360.0
        self.elevation += dy * self.orbit_sensitivity
        self.elevation = max(-89.9, min(89.9, self.elevation))
    
    def pan(self, dx, dy, viewport_h):
        """å¹³ç§»"""
        if viewport_h <= 0:
            viewport_h = 1
        scale = self.distance * self.pan_sensitivity
        
        az = math.radians(self.azimuth)
        el = math.radians(self.elevation)
        
        forward = np.array([
            math.cos(el) * math.sin(az),
            math.cos(el) * math.cos(az),
            math.sin(el)
        ], dtype=np.float32)
        
        world_up = np.array([0, 0, 1], dtype=np.float32)
        right = np.cross(forward, world_up)
        if np.linalg.norm(right) < 1e-8:
            right = np.array([1, 0, 0], dtype=np.float32)
        right /= np.linalg.norm(right)
        
        up = np.cross(right, forward)
        up /= np.linalg.norm(up)
        
        self.lookat -= right * dx * scale
        self.lookat += up * dy * scale
    
    def dolly(self, scroll_steps):
        """è·ç¦»ç¼©æ”¾"""
        factor = math.exp(-self.zoom_speed * scroll_steps)
        self.distance *= factor
        self.distance = max(self.min_distance, min(self.max_distance, self.distance))
    
    def zoom_fov(self, scroll_steps):
        """è§†åœºè§’ç¼©æ”¾"""
        factor = math.exp(-self.fov_zoom_speed * scroll_steps)
        self.fovy *= factor
        self.fovy = max(self.min_fovy, min(self.max_fovy, self.fovy))
    
    def update_clip_planes(self, model):
        """æ›´æ–°è£å‰ªå¹³é¢"""
        if hasattr(model, "vis"):
            znear = max(1e-4, self.distance * 0.01)
            model.vis.map.znear = float(znear)

class MuJoCoCameraWidget(QOpenGLWidget):
    """é›†æˆè½¨é“ç›¸æœºçš„MuJoCoæ¸²æŸ“ç»„ä»¶"""
    
    def __init__(self, model_path):
        super().__init__()
        self.setFocusPolicy(Qt.StrongFocus)
        
        # åŠ è½½æ¨¡å‹
        self.model = mujoco.MjModel.from_xml_path(model_path)
        self.data = mujoco.MjData(self.model)
        mujoco.mj_forward(self.model, self.data)
        
        # åˆå§‹åŒ–ç›¸æœº
        self.camera = OrbitCamera()
        self.camera.fit(self.model)
        
        # æ¸²æŸ“èµ„æº
        self.scene = None
        self.mjr_context = None
        self.mjcam = None
        self.opt = None
        
        # äº¤äº’çŠ¶æ€
        self.last_pos = None
        self.interaction_mode = None
        
        # ä»¿çœŸæ§åˆ¶
        self.is_running = False
        self.simulation_time = 0.0
        
        # å®šæ—¶å™¨
        self.timer = QTimer()
        self.timer.timeout.connect(self.update)
        self.timer.start(16)
    
    def initializeGL(self):
        self.scene = mujoco.MjvScene(self.model, maxgeom=20000)
        self.mjr_context = mujoco.MjrContext(self.model, mujoco.mjtFontScale.mjFONTSCALE_150)
        self.mjcam = mujoco.MjvCamera()
        self.opt = mujoco.MjvOption()
        
        mujoco.mjv_defaultCamera(self.mjcam)
        mujoco.mjv_defaultOption(self.opt)
        
        glEnable(GL_DEPTH_TEST)
        self.camera.apply_to_mjcam(self.mjcam)
        self.camera.update_clip_planes(self.model)
    
    def resizeGL(self, w, h):
        if self.model:
            glViewport(0, 0, w, h)
    
    def paintGL(self):
        if self.is_running:
            self.step_sim()
        
        self.camera.apply_to_mjcam(self.mjcam)
        self.camera.update_clip_planes(self.model)
        
        viewport = mujoco.MjrRect(0, 0, self.width(), self.height())
        
        mujoco.mjv_updateScene(
            self.model, self.data, self.opt,
            None, self.mjcam, mujoco.mjtCatBit.mjCAT_ALL, self.scene
        )
        mujoco.mjr_render(viewport, self.scene, self.mjr_context)
    
    def step_sim(self, dt_target=1/60.0):
        start = self.data.time
        steps = 0
        while (self.data.time - start) < dt_target and steps < 400:
            if self.model.nu > 0:
                ctrl = np.zeros(self.model.nu)
                self.data.ctrl[:] = ctrl
            mujoco.mj_step(self.model, self.data)
            steps += 1
        self.simulation_time = self.data.time
    
    # äº¤äº’äº‹ä»¶å¤„ç†
    def mousePressEvent(self, e):
        self.last_pos = e.position()
        buttons = e.buttons()
        mods = e.modifiers()
        
        if buttons & Qt.LeftButton and not (buttons & Qt.RightButton):
            if mods & Qt.ShiftModifier:
                self.interaction_mode = 'pan'
            else:
                self.interaction_mode = 'orbit'
        elif buttons & Qt.RightButton:
            self.interaction_mode = 'pan'
        else:
            self.interaction_mode = None
    
    def mouseMoveEvent(self, e):
        if self.last_pos is None or self.interaction_mode is None:
            return
        
        pos = e.position()
        dx = pos.x() - self.last_pos.x()
        dy = pos.y() - self.last_pos.y()
        
        if self.interaction_mode == 'orbit':
            self.camera.orbit(dx, dy)
        elif self.interaction_mode == 'pan':
            self.camera.pan(dx, dy, self.height())
        
        self.last_pos = pos
        self.update()
    
    def mouseReleaseEvent(self, e):
        self.interaction_mode = None
    
    def wheelEvent(self, e):
        steps = e.angleDelta().y() / 120.0
        mods = e.modifiers()
        
        if mods & Qt.ControlModifier:
            self.camera.zoom_fov(steps)
        else:
            self.camera.dolly(steps)
        
        self.update()
    
    def mouseDoubleClickEvent(self, e):
        if self.model:
            self.camera.fit(self.model)
            self.update()
    
    def keyPressEvent(self, e):
        if e.key() == Qt.Key_Space:
            self.toggle_sim()
        elif e.key() == Qt.Key_R or e.key() == Qt.Key_F:
            self.camera.fit(self.model)
            self.update()
    
    def toggle_sim(self):
        self.is_running = not self.is_running
        print("ğŸš€ è¿è¡Œ" if self.is_running else "â¸ï¸ æš‚åœ")

# ä½¿ç”¨ç¤ºä¾‹
def main():
    app = QApplication(sys.argv)
    
    # åˆ›å»ºä¸»çª—å£
    window = QMainWindow()
    window.setWindowTitle("MuJoCo é€šç”¨è½¨é“ç›¸æœºç¤ºä¾‹")
    window.resize(1200, 800)
    
    # åˆ›å»ºç›¸æœºç»„ä»¶
    model_path = "your_model.xml"  # æ›¿æ¢ä¸ºæ‚¨çš„æ¨¡å‹è·¯å¾„
    camera_widget = MuJoCoCameraWidget(model_path)
    window.setCentralWidget(camera_widget)
    
    window.show()
    print("=== MuJoCo é€šç”¨è½¨é“ç›¸æœº ===")
    print("æ§åˆ¶è¯´æ˜:")
    print("  å·¦é”®æ‹–åŠ¨ï¼šæ—‹è½¬")
    print("  å³é”®æ‹–åŠ¨æˆ– Shift+å·¦é”®ï¼šå¹³ç§»")
    print("  æ»šè½®ï¼šè·ç¦»ç¼©æ”¾")
    print("  Ctrl+æ»šè½®ï¼šFOV ç¼©æ”¾")
    print("  åŒå‡»æˆ–æŒ‰ F/Rï¼šè‡ªåŠ¨é€‚é…")
    print("  ç©ºæ ¼ï¼šå¼€å§‹/æš‚åœä»¿çœŸ")
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
```

### 8.2 é…ç½®æ–‡ä»¶æ”¯æŒ

```python
# camera_config.json
{
    "cameras": {
        "default": {
            "type": "orbit",
            "azimuth": 90.0,
            "elevation": -30.0,
            "distance": 2.0,
            "fovy": 45.0,
            "sensitivity": {
                "orbit": 0.35,
                "pan": 0.0025,
                "zoom": 0.12
            },
            "limits": {
                "min_distance": 0.1,
                "max_distance": 100.0,
                "min_elevation": -89.0,
                "max_elevation": 89.0
            }
        }
    },
    "interaction": {
        "orbit_mode": "left_button",
        "pan_mode": "right_button_or_shift_left",
        "zoom_mode": "wheel",
        "fov_zoom_mode": "ctrl_wheel",
        "fit_mode": "double_click_or_f_key"
    },
    "rendering": {
        "frustum_culling": true,
        "level_of_detail": true,
        "max_geoms": 20000,
        "antialiasing": true
    }
}
```

---

## 9. è°ƒè¯•å’Œç›‘æ§

### 9.1 å‚æ•°ç›‘æ§å·¥å…·

```python
class CameraMonitor:
    """ç›¸æœºå‚æ•°ç›‘æ§å·¥å…·"""
    
    def __init__(self, camera):
        self.camera = camera
        
    def get_parameters(self):
        """è·å–ç›¸æœºå‚æ•°"""
        return {
            'azimuth': self.camera.azimuth,
            'elevation': self.camera.elevation,
            'distance': self.camera.distance,
            'fovy': self.camera.fovy,
            'lookat': self.camera.lookat.tolist(),
            'position': self._calculate_position().tolist()
        }
        
    def _calculate_position(self):
        """è®¡ç®—ç›¸æœºä½ç½®"""
        az = math.radians(self.camera.azimuth)
        el = math.radians(self.camera.elevation)
        d = self.camera.distance
        
        x = d * math.cos(el) * math.sin(az)
        y = d * math.cos(el) * math.cos(az)
        z = d * math.sin(el)
        
        return self.camera.lookat + np.array([x, y, z])
        
    def log_parameters(self):
        """è¾“å‡ºç›¸æœºå‚æ•°"""
        params = self.get_parameters()
        print(f"Camera Parameters:")
        print(f"  Azimuth: {params['azimuth']:.1f}Â°")
        print(f"  Elevation: {params['elevation']:.1f}Â°")
        print(f"  Distance: {params['distance']:.2f}m")
        print(f"  FOV: {params['fovy']:.1f}Â°")
        print(f"  Position: [{params['position'][0]:.2f}, {params['position'][1]:.2f}, {params['position'][2]:.2f}]")
        print(f"  LookAt: [{params['lookat'][0]:.2f}, {params['lookat'][1]:.2f}, {params['lookat'][2]:.2f}]")
```

### 9.2 æ€§èƒ½ç›‘æ§

```python
import time

class PerformanceMonitor:
    """æ€§èƒ½ç›‘æ§å™¨"""
    
    def __init__(self):
        self.frame_times = []
        self.fps_history = []
        self.last_frame_time = time.time()
        
    def frame_begin(self):
        """å¸§å¼€å§‹"""
        self.frame_start_time = time.time()
        
    def frame_end(self):
        """å¸§ç»“æŸ"""
        frame_time = time.time() - self.frame_start_time
        self.frame_times.append(frame_time)
        
        # è®¡ç®—FPS
        if len(self.frame_times) >= 60:
            avg_frame_time = sum(self.frame_times[-60:]) / 60
            fps = 1.0 / avg_frame_time
            self.fps_history.append(fps)
            
            if len(self.frame_times) > 60:
                self.frame_times.pop(0)
                
    def get_current_fps(self):
        """è·å–å½“å‰FPS"""
        if len(self.frame_times) > 0:
            return 1.0 / self.frame_times[-1]
        return 0
        
    def get_average_fps(self):
        """è·å–å¹³å‡FPS"""
        if len(self.fps_history) > 0:
            return sum(self.fps_history) / len(self.fps_history)
        return 0
```

### 9.3 è°ƒè¯•å·¥å…·é›†æˆ

```python
class CameraDebugger:
    """ç›¸æœºè°ƒè¯•å·¥å…·"""
    
    def __init__(self, camera, monitor=None):
        self.camera = camera
        self.monitor = monitor or CameraMonitor(camera)
        self.enabled = True
        
    def enable(self):
        """å¯ç”¨è°ƒè¯•"""
        self.enabled = True
        
    def disable(self):
        """ç¦ç”¨è°ƒè¯•"""
        self.enabled = False
        
    def debug_frame(self):
        """è°ƒè¯•å¸§ä¿¡æ¯"""
        if not self.enabled:
            return
            
        params = self.monitor.get_parameters()
        print(f"[DEBUG] Camera Frame:")
        print(f"  Az: {params['azimuth']:.1f}Â°, El: {params['elevation']:.1f}Â°, Dist: {params['distance']:.2f}m")
        
    def debug_interaction(self, event_type, params):
        """è°ƒè¯•äº¤äº’äº‹ä»¶"""
        if not self.enabled:
            return
            
        print(f"[DEBUG] Interaction: {event_type}")
        for key, value in params.items():
            print(f"  {key}: {value}")
```

---

## 10. åº”ç”¨åœºæ™¯å’Œæ‰©å±•

### 10.1 æœºå™¨äººä»¿çœŸ
- **å››è¶³æœºå™¨äººæ­¥æ€è§‚å¯Ÿ**ï¼šå…¨æ–¹ä½è§‚å¯Ÿæœºå™¨äººè¿åŠ¨
- **æœºæ¢°è‡‚æ“ä½œå¯è§†åŒ–**ï¼šç²¾ç¡®è§‚å¯Ÿæœ«ç«¯æ‰§è¡Œå™¨ä½ç½®
- **å¤šæœºå™¨äººååŒä»¿çœŸ**ï¼šå¤šè§†è§’åˆ‡æ¢è§‚å¯Ÿ

### 10.2 è™šæ‹Ÿç°å®å’Œå¯è§†åŒ–
- **äº§å“å±•ç¤º**ï¼š360åº¦äº§å“å±•ç¤º
- **å»ºç­‘å¯è§†åŒ–**ï¼šå»ºç­‘æ¨¡å‹æ¼«æ¸¸
- **æ•™è‚²åŸ¹è®­**ï¼š3Dæ¨¡å‹æ•™å­¦å±•ç¤º

### 10.3 æ•°æ®å¯è§†åŒ–
- **ç§‘å­¦æ•°æ®å±•ç¤º**ï¼š3Dæ•°æ®é›†å¯è§†åŒ–
- **å·¥ç¨‹ä»¿çœŸç»“æœ**ï¼šä»¿çœŸç»“æœåŠ¨æ€å±•ç¤º
- **ç®—æ³•å¯è§†åŒ–**ï¼šç®—æ³•æ‰§è¡Œè¿‡ç¨‹å±•ç¤º

### 10.4 æ¸¸æˆå¼€å‘
- **3Dæ¸¸æˆæ‘„åƒæœº**ï¼šæ¸¸æˆä¸­çš„æ‘„åƒæœºç³»ç»Ÿ
- **åœºæ™¯ç¼–è¾‘å™¨**ï¼šæ¸¸æˆå¼€å‘å·¥å…·
- **åŠ¨ä½œé¢„è§ˆ**ï¼šåŠ¨ç”»é¢„è§ˆå·¥å…·

### 10.5 æ‰©å±•ç›¸æœºç±»å‹

#### 10.5.1 è·Ÿéšç›¸æœº
```python
class FollowCamera(OrbitCamera):
    """è·Ÿéšç›¸æœº"""
    
    def __init__(self, target_object):
        super().__init__()
        self.target_object = target_object
        self.follow_offset = np.array([0, -5, 2])
        self.look_at_offset = np.array([0, 0, 1])
        self.follow_speed = 5.0
        
    def update(self, dt):
        """æ›´æ–°è·Ÿéšä½ç½®"""
        if self.target_object:
            # è®¡ç®—ç›®æ ‡ä½ç½®
            target_pos = self.target_object.position + self.follow_offset
            target_look_at = self.target_object.position + self.look_at_offset
            
            # å¹³æ»‘è·Ÿéš
            self.position += (target_pos - self.position) * self.follow_speed * dt
            self.target += (target_look_at - self.target) * self.follow_speed * dt
```

#### 10.5.2 ç¬¬ä¸€äººç§°ç›¸æœº
```python
class FirstPersonCamera(BaseCamera):
    """ç¬¬ä¸€äººç§°ç›¸æœº"""
    
    def __init__(self):
        super().__init__()
        self.yaw = 0.0
        self.pitch = 0.0
        self.move_speed = 5.0
        self.look_speed = 0.2
        
    def update(self, dt):
        """æ›´æ–°ç›¸æœºæœå‘"""
        # æ ¹æ®åèˆªè§’å’Œä¿¯ä»°è§’è®¡ç®—æ–¹å‘
        forward = np.array([
            math.cos(self.pitch) * math.sin(self.yaw),
            math.cos(self.pitch) * math.cos(self.yaw),
            math.sin(self.pitch)
        ])
        
        self.target = self.position + forward
```

---

## 11. ç»´æŠ¤å’Œæ›´æ–°

### 11.1 ç‰ˆæœ¬æ§åˆ¶
- ä½¿ç”¨è¯­ä¹‰åŒ–ç‰ˆæœ¬å· (Semantic Versioning)
- ç»´æŠ¤å˜æ›´æ—¥å¿— (Changelog)
- ä¿è¯å‘åå…¼å®¹æ€§

### 11.2 æ–‡æ¡£ç»´æŠ¤
- æ›´æ–° API æ–‡æ¡£
- æ·»åŠ ä½¿ç”¨ç¤ºä¾‹
- æ”¶é›†ç”¨æˆ·åé¦ˆ

### 11.3 æµ‹è¯•ç­–ç•¥

#### 11.3.1 å•å…ƒæµ‹è¯•
```python
import unittest

class TestOrbitCamera(unittest.TestCase):
    """è½¨é“ç›¸æœºæµ‹è¯•"""
    
    def setUp(self):
        self.camera = OrbitCamera()
        
    def test_orbit_rotation(self):
        """æµ‹è¯•è½¨é“æ—‹è½¬"""
        initial_azimuth = self.camera.azimuth
        self.camera.orbit(90, 0)
        self.assertEqual(self.camera.azimuth, initial_azimuth + 90)
        
    def test_distance_limits(self):
        """æµ‹è¯•è·ç¦»é™åˆ¶"""
        self.camera.min_distance = 1.0
        self.camera.max_distance = 10.0
        
        self.camera.dolly(100)
        self.assertGreaterEqual(self.camera.distance, self.camera.min_distance)
        
        self.camera.dolly(-100)
        self.assertLessEqual(self.camera.distance, self.camera.max_distance)
        
    def test_fit_to_bounds(self):
        """æµ‹è¯•è´´åˆè¾¹ç•Œ"""
        # åˆ›å»ºæ¨¡æ‹Ÿæ¨¡å‹
        class MockModel:
            def __init__(self):
                self.stat = MockStat()
                
        class MockStat:
            def __init__(self):
                self.extent = 2.0
                self.center = np.array([0.0, 0.0, 0.0])
        
        model = MockModel()
        self.camera.fit(model)
        
        self.assertGreater(self.camera.distance, 0)
        np.testing.assert_array_almost_equal(self.camera.lookat, model.stat.center)

if __name__ == '__main__':
    unittest.main()
```

#### 11.3.2 é›†æˆæµ‹è¯•åœºæ™¯
```python
class CameraIntegrationTest:
    """ç›¸æœºé›†æˆæµ‹è¯•"""
    
    def test_different_models(self):
        """æµ‹è¯•ä¸åŒå¤§å°çš„æ¨¡å‹"""
        models = [
            self.create_small_model(),
            self.create_medium_model(),
            self.create_large_model()
        ]
        
        for model in models:
            camera = OrbitCamera()
            camera.fit(model)
            
            # éªŒè¯ç›¸æœºå‚æ•°åˆç†
            self.assert_valid_camera_parameters(camera)
            
    def test_extreme_parameters(self):
        """æµ‹è¯•æç«¯å‚æ•°"""
        camera = OrbitCamera()
        
        # æµ‹è¯•æç«¯è§’åº¦
        camera.elevation = 89.9
        camera.orbit(0, 10)  # åº”è¯¥è¢«é™åˆ¶
        self.assertLessEqual(camera.elevation, 89.9)
        
        # æµ‹è¯•æç«¯è·ç¦»
        camera.distance = 0.0001
        camera.dolly(-10)
        self.assertGreaterEqual(camera.distance, camera.min_distance)
        
    def test_long_running_stability(self):
        """æµ‹è¯•é•¿æ—¶é—´è¿è¡Œç¨³å®šæ€§"""
        camera = OrbitCamera()
        model = self.create_test_model()
        
        # æ¨¡æ‹Ÿé•¿æ—¶é—´æ“ä½œ
        for i in range(10000):
            camera.orbit(1, 0)
            camera.dolly(0.1)
            
            # éªŒè¯å‚æ•°ä»åœ¨åˆç†èŒƒå›´å†…
            self.assert_valid_camera_parameters(camera)
```

---

## 12. å¸¸è§é—®é¢˜è§£å†³

### 12.1 æ€§èƒ½é—®é¢˜

| é—®é¢˜ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| å¸§ç‡ä½ | æ¸²æŸ“å¯¹è±¡è¿‡å¤š | å¯ç”¨è§†é”¥å‰”é™¤ï¼Œå‡å°‘maxgeom |
| äº¤äº’å»¶è¿Ÿ | äº‹ä»¶å¤„ç†é˜»å¡ | äº‹ä»¶èŠ‚æµï¼Œå‡å°‘è®¡ç®—é‡ |
| å†…å­˜æ³„æ¼ | èµ„æºæœªæ­£ç¡®é‡Šæ”¾ | æ£€æŸ¥åœºæ™¯å¯¹è±¡ç”Ÿå‘½å‘¨æœŸ |

### 12.2 è§†è§‰é—®é¢˜

| é—®é¢˜ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| è¿‘è·ç¦»é—ªçƒ | æ·±åº¦ç²¾åº¦å†²çª | åŠ¨æ€è°ƒæ•´znear: `znear = distance * 0.01` |
| æ¨¡å‹ä¸æ˜¾ç¤º | ç›¸æœºä½ç½®é”™è¯¯ | è°ƒç”¨fit()è‡ªåŠ¨é€‚é… |
| æ¸²æŸ“ artifacts | OpenGLçŠ¶æ€é”™è¯¯ | æ£€æŸ¥OpenGLçŠ¶æ€åˆå§‹åŒ– |

### 12.3 äº¤äº’é—®é¢˜

| é—®é¢˜ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| ç›¸æœºæ§åˆ¶ä¸çµæ• | çµæ•åº¦å‚æ•°è¿‡ä½ | è°ƒæ•´sensitivityå‚æ•° |
| å¹³ç§»æ–¹å‘åäº† | åæ ‡ç³»ä¸ä¸€è‡´ | æ£€æŸ¥world_upå®šä¹‰ |
| ä¸‡å‘èŠ‚é” | ä¿¯ä»°è§’è¿‡å¤§ | é™åˆ¶elevationåœ¨[-89.9, 89.9] |

### 12.4 é›†æˆé—®é¢˜

| é—®é¢˜ | å¯èƒ½åŸå›  | è§£å†³æ–¹æ¡ˆ |
|------|----------|----------|
| MuJoCoåŒæ­¥å¤±è´¥ | ç›¸æœºå‚æ•°æœªæ­£ç¡®è®¾ç½® | æ£€æŸ¥apply_to_mjcamå®ç° |
| æ¨¡å‹åŠ è½½å¤±è´¥ | æ–‡ä»¶è·¯å¾„é”™è¯¯ | æ£€æŸ¥æ¨¡å‹è·¯å¾„å’Œæ ¼å¼ |
| ä»¿çœŸä¸åŒæ­¥ | æ—¶é—´æ­¥é•¿è®¾ç½®é”™è¯¯ | è°ƒæ•´step_simçš„dt_target |

---

## æ€»ç»“

æœ¬è®¾è®¡è¯´æ˜ä¹¦æä¾›äº†ä¸€ä¸ªå®Œæ•´çš„ MuJoCo é€šç”¨è½¨é“ç›¸æœºè§£å†³æ–¹æ¡ˆï¼Œå…·æœ‰ä»¥ä¸‹æ ¸å¿ƒä¼˜åŠ¿ï¼š

### 12.1 æŠ€æœ¯ä¼˜åŠ¿
1. **å³æ’å³ç”¨**ï¼šæä¾›å®Œæ•´çš„å®ç°ä»£ç ï¼Œå¯ç›´æ¥ä½¿ç”¨
2. **é«˜åº¦å¯å®šåˆ¶**ï¼šæ”¯æŒå‚æ•°è°ƒèŠ‚å’ŒåŠŸèƒ½æ‰©å±•
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šé’ˆå¯¹å®æ—¶æ¸²æŸ“è¿›è¡Œäº†ä¼˜åŒ–
4. **æ–‡æ¡£å®Œå–„**ï¼šæä¾›è¯¦ç»†çš„è®¾è®¡æ–‡æ¡£å’Œä½¿ç”¨æŒ‡å—

### 12.2 ç”¨æˆ·ä½“éªŒä¼˜åŠ¿
1. **ç›´è§‚æ“ä½œ**ï¼šç¬¦åˆä¸“ä¸š3Dè½¯ä»¶çš„æ“ä½œä¹ æƒ¯
2. **å“åº”è¿…é€Ÿ**ï¼šä¼˜åŒ–çš„äº¤äº’ç®—æ³•ç¡®ä¿60FPSæµç•…ä½“éªŒ
3. **å®¹é”™è®¾è®¡**ï¼šé˜²æ­¢ç”¨æˆ·æ“ä½œå¯¼è‡´å¤±æ§çŠ¶æ€
4. **è‡ªé€‚åº”**ï¼šè‡ªåŠ¨é€‚é…ä¸åŒå¤§å°çš„æ¨¡å‹

### 12.3 å¼€å‘è€…å‹å¥½
1. **æ¨¡å—åŒ–è®¾è®¡**ï¼šæ¸…æ™°çš„ä»£ç ç»“æ„ï¼Œæ˜“äºç†è§£å’Œç»´æŠ¤
2. **å®Œæ•´æµ‹è¯•**ï¼šæä¾›å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
3. **æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒå¤šç§ç›¸æœºç±»å‹å’Œé«˜çº§åŠŸèƒ½
4. **è·¨å¹³å°**ï¼šåŸºäºPySide6ï¼Œæ”¯æŒWindows/macOS/Linux

é€šè¿‡éµå¾ªæœ¬è®¾è®¡è¯´æ˜ä¹¦ï¼Œå¼€å‘è€…å¯ä»¥åœ¨ä»»ä½•éœ€è¦ 3D ç›¸æœºæ§åˆ¶çš„åº”ç”¨ä¸­å¿«é€Ÿå®ç°ä¸“ä¸šçº§çš„è½¨é“ç›¸æœºåŠŸèƒ½ã€‚æ— è®ºæ˜¯æœºå™¨äººä»¿çœŸã€æ•°æ®å¯è§†åŒ–è¿˜æ˜¯æ¸¸æˆå¼€å‘ï¼Œéƒ½èƒ½ä»ä¸­è·å¾—æ‰€éœ€çš„ä»£ç å®ç°æ–¹æ¡ˆã€‚

### 12.4 æœªæ¥å‘å±•æ–¹å‘
1. **å¤šå¹³å°æ”¯æŒ**ï¼šæ‰©å±•åˆ°Webå’Œç§»åŠ¨å¹³å°
2. **VR/ARé›†æˆ**ï¼šæ”¯æŒè™šæ‹Ÿç°å®å’Œå¢å¼ºç°å®
3. **AIè¾…åŠ©**ï¼šæ™ºèƒ½ç›¸æœºæ§åˆ¶å’Œè§†è§’ä¼˜åŒ–
4. **äº‘ç«¯æ¸²æŸ“**ï¼šæ”¯æŒåˆ†å¸ƒå¼æ¸²æŸ“å’Œäº‘ç«¯åä½œ

è¿™ä¸ªè®¾è®¡æ–¹æ¡ˆç¡®ä¿äº†ç›¸æœºæ§åˆ¶å™¨æ—¢æ»¡è¶³å½“å‰éœ€æ±‚ï¼Œåˆä¸ºæœªæ¥æ‰©å±•é¢„ç•™äº†ç©ºé—´ã€‚

---

## é™„å½•Aï¼šå®Œæ•´ä»£ç ä¸‹è½½

æœ¬è®¾è®¡è¯´æ˜ä¹¦ä¸­æä¾›çš„å®Œæ•´å®ç°ä»£ç å¯ä»¥åœ¨ä»¥ä¸‹ä½ç½®è·å–ï¼š
- GitHubä»“åº“ï¼š[é¡¹ç›®åœ°å€]
- ç¤ºä¾‹é¡¹ç›®ï¼šåŒ…å«å®Œæ•´çš„å¯è¿è¡Œç¤ºä¾‹
- æµ‹è¯•å¥—ä»¶ï¼šå®Œæ•´çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

## é™„å½•Bï¼šå‚è€ƒæ–‡çŒ®
1. MuJoCoå®˜æ–¹æ–‡æ¡£
2. OpenGLç¼–ç¨‹æŒ‡å—
3. 3Då›¾å½¢å­¦æ•°å­¦åŸºç¡€
4. PySide6å®˜æ–¹æ–‡æ¡£
5. ä¸“ä¸š3Dè½¯ä»¶äº¤äº’è®¾è®¡æŒ‡å—

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼šv1.0  
**æœ€åæ›´æ–°**ï¼š2024å¹´  
**ç»´æŠ¤è€…**ï¼šå¼€å‘å›¢é˜Ÿ